Zodでz.nativeEnumが非推奨であるという警告は、Zodのバージョン3.20.0以降で発生します。これは、z.nativeEnumがTypeScriptのenum型とJavaScriptのオブジェクトの扱い方に起因するいくつかの問題点を抱えていたためです。

非推奨になった理由

TypeScriptのEnumとZodの型の不一致: TypeScriptの数値enumは、値からキーへの逆マッピングも生成します。例えば、enum MyEnum { A, B }と定義すると、MyEnum[0]は"A"になり、MyEnum["A"]は0になります。これはZodの期待する挙動とは異なり、バリデーション時に予期せぬ結果を引き起こす可能性がありました。

型推論の複雑さ: z.nativeEnumは、TypeScriptのenumの特性を完全に考慮した型推論を行うのが難しく、開発者が意図しない型が推論されることがありました。

よりシンプルで明示的な選択肢の提供: z.enumやz.unionといったより明示的なAPIが存在するため、z.nativeEnumの必要性が薄れました。

これらの理由から、Zodの開発チームはより堅牢で予測可能なAPIであるz.enumの使用を推奨するようになりました。

変更方法

z.nativeEnumの代わりにz.enumを使用するのが推奨される方法です。z.enumは、文字列の配列を受け取り、その配列内の文字列のみを許容するenum型を定義します。

RoomTypeがTypeScriptのEnumではなく、exports.RoomTypeのようにJavaScriptのオブジェクトとして定義されているため、Object.values()を使用してenumの値を抽出できます。

code
TypeScript
download
content_copy
expand_less
import { RoomType } from "@/generated/prisma";
import * as z from "zod";

// RoomTypeの値を配列として抽出
const roomTypeValues = Object.values(RoomType) as [RoomType, ...RoomType[]];

// z.enum を使用してスキーマを定義
export const roomTypeSchema = z.enum(roomTypeValues);

export const roomSchema = z.object({
  id: z.string(),
  type: roomTypeSchema,
  firstMessage: z.string(),
  ownerId: z.string(),
});

export type RoomValue = z.infer<typeof roomSchema>;
解説

Object.values(RoomType): RoomTypeオブジェクトのすべての値（'conversation', 'image_generation'など）を含む配列を生成します。

as [RoomType, ...RoomType[]]: Zodのz.enumは少なくとも1つの要素を持つタプル型を期待します。Object.values()はstring[]を返すため、TypeScriptに対して、この配列がRoomTypeのタプルであることを型アサーションで伝えています。これにより、z.enumが正しく型推論を行えるようになります。

この変更により、nativeEnumの警告が解消され、より推奨されるZodの書き方に準拠することができます。


as [RoomType, ...RoomType[]]の部分がいまいちよくわかりません。
RoomTypeはオブジェクトですよね？
[RoomType]と書いたら、
[
{
conversation: 'conversation',
image_generation: 'image_generation',
text_to_speech: 'text_to_speech',
speech_to_text: 'speech_to_text',
image_analysis: 'image_analysis'
},
]
と書いているのと同じですよね？
[...RoomType[]] とはどのようなことをしているコードなのでしょうか？


ご質問ありがとうございます。as [RoomType, ...RoomType[]] の部分について、ご指摘の通り少し分かりにくいかもしれませんね。詳しく解説させていただきます。

まず、前提として理解しておきたいのは、TypeScriptにおける型と値の区別です。

RoomType (値):
これは、src/generated/prisma/index.js で定義されている実際のJavaScriptのオブジェクトです。

code
JavaScript
download
content_copy
expand_less
exports.RoomType = exports.$Enums.RoomType = {
  conversation: 'conversation',
  image_generation: 'image_generation',
  text_to_speech: 'text_to_speech',
  speech_to_text: 'speech_to_text',
  image_analysis: 'image_analysis'
};

このRoomTypeは、Object.values(RoomType) の引数として渡されるJavaScriptのオブジェクトそのものです。

RoomType (型):
一方で、import { RoomType } from "@/generated/prisma"; でインポートされるRoomTypeは、TypeScriptの型として使用することもできます。
この型のRoomTypeは、'conversation' | 'image_generation' | 'text_to_speech' | 'speech_to_text' | 'image_analysis' のように、RoomTypeオブジェクトの値のユニオン型を指します。

例えば、

code
TypeScript
download
content_copy
expand_less
let myRoomType: RoomType = 'conversation'; // これはOK
// let myRoomType: RoomType = 'invalid'; // これは型エラー
Object.values(RoomType) の結果

Object.values(RoomType) を実行すると、JavaScriptのオブジェクトRoomTypeのすべての値を要素とする配列が返されます。

code
JavaScript
download
content_copy
expand_less
// RoomType の値:
// {
//   conversation: 'conversation',
//   image_generation: 'image_generation',
//   text_to_speech: 'text_to_speech',
//   speech_to_text: 'speech_to_text',
//   image_analysis: 'image_analysis'
// }

const result = Object.values(RoomType);
// result は以下のようになります (実行時の値):
// ['conversation', 'image_generation', 'text_to_speech', 'speech_to_text', 'image_analysis']

TypeScriptは、このresultの型をstring[]と推論します。

z.enum が期待する型

Zodのz.enum関数は、引数として少なくとも1つの要素を持つ文字列のタプル型を期待します。具体的には、以下のような型です。

code
TypeScript
download
content_copy
expand_less
// z.enum の型定義の抜粋イメージ
function enum<T extends [string, ...string[]]>(options: T): ZodEnum<T[number]>;

このT extends [string, ...string[]]という部分が重要です。

[string, ...string[]] は「最初の要素がstringで、それ以降は0個以上のstringが続く配列」というタプル型を表します。つまり、「空ではない文字列の配列」という意味になります。

as [RoomType, ...RoomType[]] の役割

ここで、Object.values(RoomType) が返したstring[]を、z.enumが期待する[string, ...string[]]という形に型アサーションで変換しているのが as [RoomType, ...RoomType[]] です。

RoomType (型): これは先ほど説明したように、'conversation' | 'image_generation' | ... というユニオン型です。

[RoomType, ...RoomType[]]: これは「最初の要素がRoomType型の値（つまり'conversation'や'image_generation'のいずれか）で、それ以降は0個以上のRoomType型の値が続く配列」というタプル型を意味します。

つまり、Object.values(RoomType)が返したstring[]が、実際にRoomType型の要素のみからなる空ではない配列であることをTypeScriptに教えているのです。

なぜこのような型アサーションが必要か？

string[] と [string, ...string[]] の違い:

string[] は空の配列[]も許容します。

[string, ...string[]] は「少なくとも1つの要素を持つ」ことを保証します。
z.enumは空の配列では機能しないため、この「少なくとも1つの要素」の保証が必要です。

型推論の精度:
Object.values()はJavaScriptの実行時の結果なので、TypeScriptはstring[]としか推論できません。しかし、我々は開発者として、その中身が確実にRoomType型の値であることを知っています。この知識をTypeScriptに伝えることで、z.enumがより正確な型（ZodEnum<RoomType>）を生成できるようになります。

まとめ

Object.values(RoomType) は、JavaScriptのオブジェクトRoomTypeの値からなる配列 (['conversation', ... ]) を生成し、TypeScriptはこれをstring[]と推論します。

z.enumは、「空ではない文字列のタプル型」を期待します。

as [RoomType, ...RoomType[]] は、Object.values(RoomType) の結果が実際に空ではなく、かつその要素がRoomType型の値である配列である、ということをTypeScriptに伝えるための型アサーションです。これにより、z.enumが期待する型を満たし、より正確なZodスキーマの型推論が可能になります。

ご指摘のあった、[RoomType]がオブジェクト自体を指すという解釈は、TypeScriptの型とJavaScriptの実行時の値の混同からくるものだと思います。asの後ろに書かれるRoomTypeは、あくまで「型」として解釈されます。
